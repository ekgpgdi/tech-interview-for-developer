# **[Java]**

# JVM
## JVM 이란 무엇인가요?
Java Virtual Machine 의 줄임말로, 직역하면 ‘자바를 실행하기 위한 가상 기계/컴퓨터’라고 할 수 있습니다. <br/>
개발자들이 말하는 JVM은 보통 **어던 기기상에서 실행되고 있는 프로세스, 특히 자바 앱에 대한 리소스를 대표하고 통제하는 서버**를 지칭합니다. <br/>
<br>
## JVM이 필요한 이유는 뭘까요?
Java는 OS에 종속적이지 않다는 특징을 가지고 있습니다. 따라서 OS에 족속받지 않고 실행되려면 OS위에서 Java를 실행시킬 무언가가 필요한데, 그 역할을 하는게 JVM 입니다.<br/>
쉽게 말해서, OS에 종속받지 않고 CPU가 Java를 인식하고 실행할 수 있게 하는 가상 컴퓨터 입니다.
<br>
## JVM에서의 메모리 관리는 보통 어떻게 하나요?
JVM 실행에 있어서 가장 일반적인 상호작용은, 힙과 스택의 메모리 사용을 확인하는 것입니다.

## JVM 실행 과정은 어떻게 되나요?
1. 프로그램이 실행되면, JVM은 OS로부터 이 프로그램이 필요로하는 메모리를 할당받습니다. JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리합니다.<br>
2. 자바 컴파일러(JAVAC)가 자바 소스코드를 읽고, 자바 바이트코드(.class)로 변환시킵니다.<br>
3. 변경된 class 파일들을 클래스 로더를 통해 JVM 메모리 영역으로 로딩합니다.<br>
4. 로딩된 class 파일들은 Execution engine을 통해 해석됩니다.<br>
5. 해석된 바이트 코드는 메모리 영역에 배치되어 실직적인 수행이 이루어집니다. 이러한 실행 과정 속 jvm은 필요에 따라 스레드를 동기화나 가비지 컬렉션 같은 메모리 관리 작업을 수행합니다.<br>

### 이해를 위한 용어 정리
- 자바 컴파일러 : 자바 소스코드(*.java)를 바이트 코드(*.class)로 변환 시켜준다
- 클래스 로더 : JVM은 런타임시에 처음으로 클래스를 참조할 때 해당 클래스를 로드하고 메모리 영역에 배치시킨다. 이 동적 로드를 담당하는 부분이 바로 클래스 로더다
- Runtime Data Areas : JVM이 운영체제 위에서 실행되면서 할당받는 메모리 영역이다. 총 5가지 영역으로 나누어진다. <br/>
    - PC 레지스터 : 스레드가 어떤 명령어로 실행되어야 할 지 기록하는 부분입니다.
    - 스택 area : 지역변수, 매개변수, 메서드 정보, 임시 데이터 등을 저장합니다.
    - 네이티브 메서드 스택 : 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역입니다.
    - 힙 : 런타임에 동적으로 할당되는 데이터가 저장되는 영역입니다. 객체나 배열 생성이 여기에 해당합니다. <br/>
      (힙에 할당된 데이터들은 가비지컬렉터의 대상이 됩니다. JVM 설능 이슈에서 가장 많이 언급되는 공간입니다.)
    - 메서드 영영 : JVM이, 시작될 때 생성되고, JVM이 읽은 각각의 클래스와 인터페이스에 대한 런타임 상수 풀, 필드 및 메서드 코드, 정적 변수, 메서드의 바이트 코드 등을 보관합니다.

## 가비지 컬렉션 (Garbage Collection)
보통 줄여서 GC라고 부릅니다. 자바 이전에는 프로그래머가 모든 프로그램 메모리를 관리했지만 자바에서는 JVM이 이 프로그램 메모리를 관리합니다.
<br>이 때 JVM은 GC라는 프로세스를 통해 메모리를 관리합니다. 가비지 컬렉션은 자바 프로그램에서 사용되지 않는 메모리를 지속적으로 찾아내서 제거하는 역할을 합니다.

### 실행순서
1. 참조되지 않은 객체들을 탐색 후 삭제
2. 삭제된 객체의 메모리 반환
3. 힙 메모리 재사용

<br/>

-----

<br/>

> ## Collection Framework 란?
- 컬렉션 : 다수의 객체(데이터)를 모아 놓은 것
- 다수의 객체를 다루기 위해 표준화된 프로그래밍 방식
- Java.util 패키지에 포함
- Collection Framework의 구조
![](https://velog.velcdn.com/images/seonmikimm/post/2066bae4-808f-434c-afb4-a8d4b9079027/image.png)


> ## List란? 
- 순서가 있는 데이터의 집합으로 중복을 허용한다.
- List 인터페이스를 구현하는 클래스
    - ArrayList 
    - LinkedList 
    - Vector : ArrayList와 거의 동일한 기능이며, 컬렉션 프레임워크가 도입되기 이전부터 지원하는 클래스
        - Stack : Vector 클래스를 상속

> ## ArrayList와 LinkedList를 언제 사용하는가?
### ArrayList
- 모든 객체의 최상위 타입인 Object 배열 기반, 객체 접근에 탁월함
- 배열 크기가 고정되어 있고 중간에 데이터 삽입/삭제 시 배열 전체의 크기 변경 연산이 필요함
- 무작위 접근이 가능하여 조회 속도가 높음
- 데이터 개수가 변하지 않는 경우, 검색/조회에 사용한다.
### LinkedList
- Node 객체 연결 기반
- Node 클래스는 자신의 데이터와 연결된 데이터의 주소로 이루어져 있음
- 연속적인 메모리 할당이 필요하지 않고 데이터를 특정 주소에 저장하여 주소를 연결
- 연결된 노드를 통해 순차적인 접근을 해야 하므로 접근 속도가 느림
- 데이터 삽입/삭제 시 노드 연결만 추가/삭제하면 됨
- 데이터 개수의 변경이 빈번한 경우, 삽입/삭제에 사용한다.

> ## Set 이란? 
- 순서를 유지하지 않는 데이터의 집합으로 중복을 허용하지 않는다.
- Set 인터페이스를 구현하는 클래스
    - HashSet : 가장 기본적인 Set 클래스로, hash에 의해 데이터의 위치를 특정시켜 해당 데이터를 빠르게 조회할 수 있다.
    - TreeSet : 특정 규칙에 의해 데이터를 정렬하는 자료 구조인 Tree와 중복을 허용하지 않는 Set 자료구조가 결합되었다.
    - LinkedHashSet : 중복을 허용하지 않는 Set 자료구조의 순서를 유지하고 싶을 때 사용한다.

> ## Map 이란? 
- 키와 값의 쌍으로 이루어진 데이터의 집합
- 순서를 유지하지 않으며, 키는 중복을 허용하지 않고, 값은 중복을 허용한다.
- Map 인터페이스를 구현하는 클래스
    - HashMap
    - TreeMap
    - LinkedHashMap
    - HashTable


> ## Stack 이란?
- Stack은 '쌓아 올리다' 라는 의미로, 가장 마지막에 쌓아 올린 짐이 가장 위에 있고, 가장 먼저 사용한다.
- LIFO(Last in First out) 또는 후입선출
- Vector 클래스를 상속하는 클래스로, 모두 Vector에 있는 메소드를 이용하여 구현되어 있다.
- Stack의 활용 예 
    - 웹 브라우저의 뒤로가기, 워드프로세서의 undo/redo, 수식계산

> ## Queue 란?
- Queue는 '대기열' 이라는 의미
- FIFO(First-in First-out) 또는 선입선출
- 시간 순으로 데이터를 처리할 때 사용한다.
- Queue의 활용 예
    - 최근 사용 문서, 인쇄 작업 대기목록, Buffer

<br/>

----
<br/>


# Q. 메모리 영역을 구분하여 설명한다면?

- java.exe로 JVM이 시작되면 운영체제에서 할당받은 메모리 영역(***Runtime Data Area***)을 다음과 같이 세부 영역으로 구분해서 사용

**메소드 영역** 

- 클래스들을 클래스로더로 읽어 클래스별로 분류해서 저장
- JVM이 시작할 때 생성, 모든 스레드가 공유하는 영역

**Heap 영역**

- 객체와 배열이 생성되는 영역
- 생성된 객체와 배열은 JVM 스택 영역의 변수나 다른 객체의 필드에서 참조

**JVM 스택 영역**

- 각 스레드마다 하나씩 존재하며 스레드가 시작될때 할당됨
- 메소드를 호출하면 프레임 추가(push), 메소드가 종료되면 프레임 제거(pop) 수행(지역변수, 메소드 등이 할당)

***Garbage Collector***

- GC는 힙 영역에서 사용하지 않는 객체들을 제거하는 작업(객체를 제거하는 작업이 필요한 이유는 개발자가 메모리를 직접 해제해줄 수 없는 언어이기 때문)
- GC 수행시 시스템이 멈추기 때문에 의도치 않은 장애의 원인이 될 수 있습니다. 따라서 이를 위해 힙 영역을 조정하는 것을 GC 튜닝이라고 하고 JVM 메모리는 절대 마음대로 조정해선 안됩니다.

<br/>

---
<br/>

# Java 8과 11의 특징

## Java 8

- Heap Permanent Generation 제거
- 인터페이스에 디폴트 메소드와 정적 메소드 추가
- 함수형 인터페이스, 람다 표현식, 메소드 참조 기능 추가
    - 주로 함수형 인터페이스의 익명 객체를 대체하기 위해 람다식을 사용하며, 간결하고 부수 효과가 없는 코드를 만들어 낼 수 있게 된다.
- 스트림 API 도입
- 새로운 날짜 관련 라이브러리 추가
    - LocalDate, LocalTime, LocalDateTime 등의 라이브러리
    - 기존에 사용하던 날짜 관련 클래스인 Date, Calendar 등은 가변 객체이므로 Thread-Safe하지 않다.
- Optional 지원
    - Optional을 통해 null에 대한 참조를 안전하게 할 수 있다.
- 병렬 처리 지원

## Java 11 

- 람다에서 로컬 변수 Var 사용 가능
- Files 클래스에 새로운 메소드 추가
    - writeString()
    - readString()
    - isSameFile()
    - 등과 같은 다양한 메소드가 있어 파일에 대해 여러 작업을 수행 할 수 있음.
- String 에 새로운 메소드 추가
    - `strip()`: 문자열 앞, 뒤의 공백 제거.
    - `stripLeading()`: 문자열 앞의 공백 제거.
    - `stripTrailing()`: 문자열 뒤의 공백 제거.
    - `isBlank()`: 문자열이 비어있거나, 공백만 포함되어 있을 경우 true를 반환한다.
        - `String.trim().isEmpty()` 와 결과가 동일함.
    - `repeat(n)`: n개만큼 문자열을 반복하여 붙여서 반환함.
- 자바 파일 실행 방식 단순화
    - javac를 통해 컴파일 하지 않고도, 바로 java 파일을 실행할 수 있게 되었다.

<br/>

---
<br/>

## maven, gradle의 특징과 차이는?
### build tool
- 소스 코드를 통해 실행 가능한 애플리케이션 생성을 자동화하는 프로그램
- 기본적으로 빌드 자동화는 소프트웨어 개발자가 다음과 같은 일상적인 활동에서 수행하는 다양한 작업을 스크립트화, 자동화하는 행위이다.
    - 종속성을 다운로드
    - 소스 코드를 바이너리 코드로 컴파일
    - 바이너리 코드를 패키징
    - 테스트를 실행
    - 프로덕션 시스템에 배포

### maven 
- apache ant의 대안으로 만들어진 Java 빌드 도구이다.
- xml을 기반으로 스크립트를 작성한다.(pom.xml)
- 정적인 데이터를 저장하는 xml파일이기에 동적인 정의가 어렵다.
- pom.xml : "Project Object Model"의 약자로, 프로젝트의 다양한 정보를 처리하기 위한 객체 모델이다. pom.xml 파일에는 프로젝트 관리 및 빌드에 필요한 환경 설정, 의존성 관리 등의 정보들을 기술한다.

### gradle 
- Ant와 Maven의 개념을 기반으로 구축되어 Ant와 Maven의 단점을 보완하고 장점을 취합한 Java 빌드 도구이다.
- Ant와 Maven과는 달리 xml파일을 사용하지 않고, xml의 구조적인 틀에서 벗어나 간결한 정의가 가능
- Groovy언어를 기반으로 동적인 정의가 가능하다.
- Groovy 언어 기반 DSL(Domain-Specific Language)을 사용하여 특정 도메인 문제를 해결하도록 설계되었기 때문에 구성 파일의 크기가 작아졌다.(build.gradle에 작성)
- DSL 
    - DSL은 특정 도메인에 최적화된 프로그래밍 언어를 뜻한다.
- Groovy
    - JVM에서 실행되는 스크립트 언어로 문법이 Java와 매우 비슷하다.
    - java와 호환이 되고 java 클래스 파일을 그대로 Groovy 클래스로 사용할 수 있다. 

<br/>

---

<br/>

# 오버로딩과 오버라이딩의 차이

### 오버로딩(overloading)
이름은 같지만 시그니처(파라미터 수, 타입)는 다른 메소드를 중복으로 선언하는 것을 의미 
<br/>
📌 같은 메소드랃 매개변수만 다르면 얼마든지 정의하고 사용이 가능

```
void test() {
    ...
}

void test(int a, int b) {
    ...
}
```

### 오버라이딩 (overriding)
부모 클래스의 메소드 동작 방법을 변경(재정의)하여 우선적으로 사용하는 것
<br/>
📌 상속 관계에 있는 클래스 간에 같은 이름의 메소드를 정의하는 기술

```
public class People {
    public void print() {
        System.out.println("안녕하세요.");
    }
}

public class Student extends People {
    // print() 메소드 오버라이딩
    public void print() {
        System.out.println("안녕하세요.");
        System.out.println("저는 학생입니다.");
    }
}
```

<br/>

---
<br/>

## Q. 자바 컴파일 과정에 대해 말해주세요.
### A.
1. 텍스트 파일인 자바소스파일을 만들고 컴파일되면 바이트코드파일이 생성됨
2. 바이트 코드파일은 완전한 기계어가 아니므로 구동시키기 위해서 JVM 실행시킴 (명령어 java.exe)
3. 명령어가 실행되면 JVM은 바이트 코드파일을 메모리로 로드
(클래스 로더 -> Runtime Data Area -> Excution Engine)
4. 기계어로 번역
5. main() 메소드 찾아서 실행
* 실행문 : 변수 선언, 값 저장, 메소드 호출에 해당하는 코드

</br>
</br>

# 자바 컴파일 과정
![](https://velog.velcdn.com/images/ilov-/post/a42c3fd3-d843-4746-800e-90d217bb91aa/image.jpeg)

1. 개발자가 자바 소스코드를 작성
2. 자바 컴파일러가 자바 소스파일을 컴파일  
(이때 나오는 파일은 자바 바이트 코드(.class)파일로 아직 컴퓨터가 읽을 수 없는 자바 가상 머신이 이해할 수 있는 코드)
3. 컴파일된 바이트 코드를 JVM의 클래스로더에게 전달
4. 클래스 로더는 동적로딩(Dynamic Loading)을 통해 필요한 클래스들을 로딩 및 링크하여 JVM의 메모리(Runtime Data area)에 올림
> <details>
><summary>클래스 로더 세부 동작</summary>
>
><!-- summary 아래 한칸 공백 두어야함 -->
>     1. 로드 : 클래스 파일을 가져와서 JVM의 메모리에 로드  
>     2. 검증 : 자바 언어 명세(Java Language Specification) 및 JVM 명세에 명시된 대로 구성되어 있는지 검사  
>     3. 준비 : 클래스가 필요로 하는 메모리를 할당 (필드, 메서드, 인터페이스 등등)  
>     4. 분석 : 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경 -> 추가 공부 필요  
>     5. 초기화 : 클래스 변수들을 적절한 값으로 초기화 (static 필드)  
> </details>
5. Execution Engine은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행 (두가지 방식)

> <details>
><summary>인터프리터, JIT 컴파일러</summary>
>
><!-- summary 아래 한칸 공백 두어야함 -->
>
> 1. 인터프리터 
> - 바이트 코드 명령어를 하나씩 읽어서 해석하고 실행. 하나하나의 실행은 빠르나, 전체적인 실행 속도가 느림. 
>  
> 2. JIT 컴파일러(Just-In-Time Compiler) 
>  - 인터프리터의 단점을 보완하기 위해 도입된 방식으로 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경하고  
>  이후에는 해당 메서드를 더이상 인터프리팅 하지 않고, 바이너리 코드로 직접 실행하는 방식  
>  - 하나씩 인터프리팅하여 실행하는 것이 아니라 바이트 코드 전체가 컴파일된 바이너리 코드를 실행하는 것이기 때문에 전체적인 실행속도는 인터프리팅 방식보다 빠름
></details>

<br/>

---
<br/>

> ## 추상클래스와 인터페이스의 차이점은?
### 추상클래스
- 하나 이상의 추상 메소드를 포함하며 `abstract` 로 정의된 클래스이다.
- 추상클래스는 미완성(abstract) 상태이므로 인스턴스를 생성할 수 없고 상속을 통해 자손 클래스로만 완성될 수 있다.
- 추상클래스는 추상메소드를 포함한다는 것을 제외하면 일반 클래스와 다르지 않으며 일반 메소드와 일반 변수를 함께 사용할 수 있다.
- 추상 클래스를 포함한 모든 자바 클래스는 `다중 상속 시 모호성` 때문에 구현 객체의 동일함이 보장되지 않으므로 다중 상속이 불가능하다.
- 추상클래스는 클래스 상속 시 `extends(확장)`을 사용하며, 추상클래스를 이어 받아 기능을 확장하려는 목적으로 사용한다.

### 인터페이스
- 인터페이스는 일종의 추상클래스이며, 추상클래스와 마찬가지로 인스턴스를 생성할 수 없고 상속만 가능하다.
- 모든 메소드가 추상메소드이며 오직 추상메소드와 상수만을 멤버로 가질 수 있다. (JDK 1.8 부터 static 메소드와 default 메소드를 가질 수 있다)
- 인터페이스는 다른 인터페이스를 `extends(확장)` 을 사용해 상속하여 확장할 수 있으며, 다중상속이 가능하다.
- 인터페이스는 클래스 상속 시 `implements(구현)` 을 사용하며, 인터페이스에 정의된 추상메소드를 각 클래스의 목적에 맞게 기능을 구현하려는 목적으로 사용한다.
- 인터페이스를 작성하면 구현하지 않아도 사용이 가능하므로 프로그램을 작성할 수 있고 동시에 다른 사람은 인터페이스를 구현할 수 있으므로 `개발 시간이 단축`된다.

<br/>

---
<br/>

# **[Spring]**

## @Transactional 동작 원리

@Transactional이 클래스 내지 메서드에 붙을 때, Spring은 해당 메서드에 대한 프록시를 만든다. <br/>

> 프록시 패턴은 디자인 패턴 중 하나로, 어떤 코드를 감싸면서 추가적인 연산을 수행하도록 강제하는 방법이다.

<br/>
트랜잭션의 경우, 트랜잭션의 시작과 연산 종료시의 커밋 과정이 필요하므로, 프록시를 생성해 해당 메서드의 앞뒤에 트랜잭션의 시작과 끝을 추가하는 것이다. <br/>
이러한 로직은 AOP에 바탕을 두고 설계되었기 때문에, 이후 설명에서 해당 프록시는 트랜잭션 AOP로 명칭하겠다. <br/>
<br/>
<br/>
또한, 스프링 컨테이너는 트랜잭션 범위의 영속성 컨텍스트 전략을 기본으로 사용한다. <br/>
<br/>
서비스 클래스에서 @Transactional을 사용할 경우, 해당 코드 내의 메서드를 호출할 때 영속성 컨텍스트가 생긴다는 뜻이다. 
<br/> 영속성 컨텍스트는 트랜잭션 AOP가 트랜잭션을 시작할 때 생겨나고, 메서드가 종료되어 트랜잭션 AOP가 트랜잭션을 커밋할 경우 영속성 컨텍스트가 flush되면서 해당 내용이 반영된다. 
<br/> 이후 영속성 컨텍스트 역시 종료되는 것이다.

출처 : https://kafcamus.tistory.com/30

<br/>

---
<br/>

 ## Q1. DI 사용이유
 ### A1. 
- 의존성을 외부에서 주입해 결합도가 낮추기 위해 사용합니다. 그로 인해 코드 수정이 쉬워지며, 테스트 코드 작성도 쉬워집니다.</p>
- IoC를 실현하는데 DI가 필수이며 IoC를 사용하면 귀찮은 객체 생명 주기 같은 프로그램 제어권을 프레임워크가 관리하도록 넘길 수 있습니다.

</br>
</br>

 ## Q2. IoC 컨테이너의 역할
 ### A2.
 **IoC(Inversion of Control)** 
- 메소드나 객체의 호출작업을 개발자가 아닌 Spring Framework에서 결정
- 객체의 생명주기를 관리하고 생성된 인스턴스들에 추가적 기능을 제공하도록 함
- 기존에는 객체를 클래스 내부에서 생성하고 사용했지만 IoC를 적용하면 미리 생성해놓은 객체를 주입받아 사용하기만 하면 됩니다. 
- 객체 간 결합도를 낮춤, 유연한 코드 작성, 가독성 증진, 코드 중복 방지, 유지 보수 용이 등의 장점이 있습니다. 

</br>
</br>

# IoC(Inversion of Control) - 제어의 역전
`IoC`
- 메소드나 객체의 호출작업을 개발자가 아닌 외부에서 결정(외부는 Spring Framework)
- 기존에는 객체를 클래스 내부에서 생성하고 사용했지만 IoC를 적용하면 미리 생성해놓은 **객체를 주입받아** 사용하기만 하면 됨

`장점`

- 객체 간 결합도를 낮춤, 유연한 코드 작성, 가독성 증진, 코드 중복 방지, 유지 보수 용이

`컨테이너`
- 객체의 생명주기를 관리, 생성된 인스턴스들에 추가적 기능을 제공하도록 함


`IoC컨테이너`
- 객체의 생성을 책임지고, 의존성을 관리
- Pojo의 생성,초기화,서비스,소멸에 대한 권한을 가짐, 따라서 개발자는 비지니스 로직에 집중 가능. 


</br>
</br>


# D.I(Dependency Injection) - 의존성 주입
- 객체 사이의 의존 관계를 스프링 설정 파일에 등록된 정보를 바탕으로 컨테이너가 자동으로 처리해주는 것
- 컨테이너가 직접 객체들 사이의 의존관계를 처리하는 것
- 스프링 설정 파일에 등록된 정보를 바탕으로 하기 때문에, 직접 코드를 바꾸지 않고 스프링 설정 파일을 변경하는 것만으로 유지보수가 가능하기 때문에
의존성이 줄어들고, 재사용성과 가독성이 높아지며 보다 객체지향에 부합하는 방식의 코드를 작성가능

### 방법
`1. 생성자 주입` 
```java
@Autowired
public void MemberController(MemberService memberService){
               this. memberService = memberService;
}

@Autowried
필요한 의존객체의 ‘타입’에 해당하는 빈을 찾아서 주입해주는 어노테이션
Ioc컨테이너가 빈으로 등록해주기 때문에, 빈으로 등록 되어 있는 것들은 autowired로 꺼낼 수 있다. 
	→ applicatonContext도 꺼낼 수 있다.
```

- 생성자에 의존성을 주입받고자하는 field를 나열하는 방법.
- 필수적으로 사용해야하는 레퍼런스 없이는 인스턴스를 만들지 못하도록 강제함 - 스프링 컨테이너가 올라오고 어플리케이션이 setting되는 시점에 생성자 주입을 통해 한번만 호출하는 것이 보장되어 `불변, 필수`의존관계에 사용

</br>

`2. Setter 주입`
- set이 public하게 노출될 경우 setter가 실행되어 변경될 수 있는 문제점을 가짐
- 변경가능성이 존재하는 의존관계에서 사용할 필요가 있으나 권장되지 않음 

</br>

`3. 필드 주입`
- 필드에 @Autowired 어노테이션을 붙임. 중간에 외부에서 변경이 불가능하기 때문에 테스트가 힘듦


</br>
</br>

>[DI, IoC ](https://velog.io/@ilov-/Spring-DI-IoC-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%8B%B1%EA%B8%80%ED%86%A4)

<br/>

---
<br/>

## DTO 란?
Data Transfer Object <br/>
<br/>
계층 간 데이터 교환을 하기 위해 사용하는 객체로, DTO는 로직을 가지지 않는 순수한 데이터 객체(getter & setter 만 가진 클래스) <br/>
<br/>
DTO는 클라이언트 요청에 포함된 데이터를 담아 서버 측에 전달하고, 서버 측의 응답 데이터를 담아 클라이언트에 전달하는 계층간 전달자 역할
<br/>

## DTO 사용 이유?
* Entity가 아닌 DTO를 전달함으로써 레이어간의 역할을 분담 <br/>
* 도메인 객체를 캡슐화 <br/>
* 필요한 데이터만 선택적으로 <br/>

<br/>

---
<br/>

## Filter 란?
필터는 스프링의 독자적인 기능이 아닌 자바 서블릿에서 제공하는 기능 <br/>
<br/>
스프링 프레임워크는 들어온 요청이 DispatcherServlet에 의해 컨트롤러에 매핑 <br/>
Filter는 요청이 <b>DispatcherServlet에 의해 다뤄지기 전, 후</b>에 동작 <br/>
<br/>
Filter는 FilterChain(필터 체인)을 통해 여러 필터가 연쇄적으로 동작하게 할 수 있음 <br/>
<br/>

### Filter 의 메소드 
1. init() : 필터 가 생성될 때 수행되는 메소드
2. doFilter() : Request, Response가 필터를 거칠 때 수행되는 메소드
3. destroy() : 필터가 소멸될 때 수행되는 메소드

<br/>

---
<br/>

# Spring Data JPA
## ORM이란 무엇인가요?
**Object Relational Mapping**의 줄임말로, 객체와 관계형 데이터베이스간에 데이터를 자동으로 매핑해주는 기술입니다.

## JPA, Hibernate, Spring Data JPA는 각각 무엇인가요?
- JPA는 자바 진영의 ORM을 위한 명세를 의미합니다.
- Hibernate란 자바 진영의 ORM 명세인 JPA를 구현한 여러 구현체 중 하나를 의미합니다.
- Spring Data JPA는 Spring 환경에서 편리하게 사용할 수 있도록 Repository 기반으로 추상화 시킨 스프링 서브 프로젝트입니다.

## 프로젝트에 JPA를 사용하신 이유가 뭔가요?
프로젝트가 진행되면서 발생하는 반복 쿼리문을 없애고, 좀 더 객체지향적으로 코드를 작성하고 싶어서 JPA를 사용했습니다.

## JPA의 장/단점은 무엇이 있나요?
장점으로는 개발자가 반복되는 쿼리를 직접 작성하지 않아도 되면서 개발 생산성이 올라가 효율이 증가하는 점이 있습니다. 단점으로는 Pesistent Context에서 Cache, Write Behind, Dirty Checking, Lazy Loading 등 다양한 기능을 지원해주는데 개념을 잘 모르고 JPA를 사용했을 경우 수많은 예외와 성능 감소가 발생할 수 있다는 점이 있습니다.

## JPA Entity의 상태 변화에 대해서 설명해주시겠어요?
JPA Entity 상태에는 Transient, Persistent, Detached, Removed 상태가 존재합니다.
- Transient 상태는 객체가 새롭게 생성된 상태를 의미하며 Persistent Context에서 관리하지 않는 상태입니다.
- Persistent는 Persistent Context에 의해 관리되며 해당 엔티티는 1차 Cache, Write Behind, Dirty Checking 등의 다양한 기능을 제공받을 수 있습니다.
- Detached는 해당 엔티티를 더이상 Persistent Context에서 관리하지 않는 상태를 의미합니다.
- Removed는 데이터베이스로부터 해당 엔티티를 제거한 상태를 의미합니다.

## 영속성은 어떻게 유지되고 DB에 저장되는 건가요?
1. Transaction이 시작합니다.
2. 새로운 Entity 객체를 생성합니다.
3. Persistent Context에 Entity 객체를 올립니다.
4. Persistent Context는 해당 Entity를 관리하면서 Dirty Checking이나 1차 Cache 등의 다향한 기능을 제공해줍니다.
5. 트랜잭션이 커밋되기 전에 flush가 발생하며 Persistent Context의 변경 내용들이 데이터베이스에 반영됩니다.
6. 트랜잭션 커밋됩니다.

### 용어 정리 갑니다~
#### 1차 Caching 이란 ?
flush가 발생하기 전까지 Persistent Context 내부에서 엔티티를 캐싱하는 것을 1차 캐싱이라고 합니다.

#### Dirty Checking 이란?
Persistent Context 에서 flush가 일어날 때 **저장된 엔티티와 스냅샷의 상태를 비교해서 서로 다르면 알맞는 쿼리문을 데이터베이스에 반영하는 것**입니다.

#### Lazy Loading 이란?
Lazy Loading 이란 DB로부터 엔티티를 가져올 때 참조된 엔티티와 관련된 select 쿼리가 발생하는 것이 아닌, **프록시를 통해서 직접 참조된 엔티티를 사용될 경우에 select 쿼리가 발생하는 것**을 의미합니다.

#### 어떤 경우에 즉시 Loading을 쓰는 것이 좋은가?
DB로부터 직접 가져오는 엔티티와 이에 참조된 엔티티가 자주 같이 사용된다면 즉시 로딩을 사용하면 좋습니다.

#### Querydsl 이란?
Type-safe한 방식으로 쿼리를 작성할 수 있도록 도와주는 프레임워크를 의미합니다. 컴파일 타임에 쿼리의 문법 오류를 검증할 수 있고, IDE 자동 완성 기능을 사용해서 보다 Type-safe한 쿼리를 작성할 수 있습니다.

<br/>

---
<br/>


## Q1. Spring MVC 사용이유에 대해 말해주세요.
### A1.
Spring MVC는 HTTP Request를 처리하는 부분인 Controller, 데이터를 처리해 정제된 데이터를 넣는 Model, 
정제된 데이터를 활용해 사용자에게 보여지는 View에 대한 역할 분리를 잘 해놓은 프레임워크입니다.
Spring MVC 패턴을 사용하면 Model, View, Controller 모두를 인터페이스를 사용해 규격화해놓아 유연하고 확장성 있게 웹 어플리케이션을 설계할 수 있습니다.

</br>

## Q2. Spring Web MVC의 Dispatcher Servlet의 동작 원리에 대해서 간단히 설명해주세요.
### A2.
- DispatcherServlet은 Spring MVC의 가장 중요한 요소로 모든 클라이언트의 요청을 가장 먼저 받아들이는 역할을 수행합니다. 
- 즉, 사용자의 요청을 가장 먼저 받아 요청에 알맞는 Handler, Controller에 위임해주는 역할입니다. 

1. 클라이언트의 요청을 dispathcer servlet이 받습니다.
2. HandlerMapping을 통해 요청을 처리할 Controller를 검색합니다.
3. 검색 된 Controller를 실행하여 클라이언트의 요청을 처리합니다. 
4. Controller는 비즈니스 로직을 수행하고 , ModelAndView 객체를 리턴합니다.
5. ModelAndView로부터 View 정보를 추출하고, ViewResolver를 이용하여 응답으로 사용할 view를 얻습니다.
6. View를 실행하여 응답을 전송합니다. 

</br>
</br>
</br>

# Spring MVC 프레임워크와 구조
### 1. Spring MVC
- Spring에서 제공하는 웹 모듈로, Model, View, Controller 세가지 구성요소를 사용해 사용자의 다양한 HTTP Request를 처리하고 
  단순한 텍스트 형식 응답부터 REST 형식의 응답, View를 표시하는 html을 return하는 응답까지 다양한 응답을 할 수 있는 프레임 워크
- 다양한 요쳥을 처리하고 응답하기 위해 주요 구성요소들을 만들어놓고 구성요소들을 확장할 수 있게 만들어 놓음

>  ![](https://velog.velcdn.com/images/ilov-/post/530888e3-d0e6-42ce-8049-db9ee04fccd5/image.png)

</br>

### 2. 구조

**DispatcherServlet(Front Controller)**
- 서블릿 컨테이너에서 http 프로토콜을 통해 들어오는 모든 request에 대해 제일 앞단에서 중앙집중식으로 처리해주는 핵심적인 역할
(앞쪽에서 처리하는 컨트롤러를 두는 패턴 : Front Controller 패턴)

**HandlerMapping**
- 클라이언트의 request url을 어떤 컨트롤러가 처리해야 할 지 찾아서 Dispatcher Servlet에게 전달해주는 역할
- 컨트롤러 상에서 url을 매핑시키기 위해 @RequestMapping을 사용하는데, 핸들러가 이를 찾아줌

**Handler(Controller)**
- HTTP Request를 처리해 Model을 만들고 HTTP가 보여줄 View Name을 지정
- 실질적인 요청을 처리하는 곳이고, Dispatcher Servlet이 프론트 컨트롤러라면, 이 곳은 백엔드 컨트롤러라고 볼 수 있음
- Model의 처리 결과를 담아 Dispatcher Servlet에게 반환

**ModelAndView**
- Controller에 의해 반환된 Model과 View가 Wrapping된 객체
- View가 지정되더라도 데이터가 세팅된 View가 지정되지 않음

**ViewResolver**
- String 형태로 넘어온 viewName을 받고, Model에 저장된 데이터를 사용해 View 객체 생성
- 컨트롤러의 처리 결과를 만들 view를 결정해주는 역할

**View**
-  모델과 viewName 받아서 화면에 그려주는 역할 수행

</br>


> [Spring MVC 과정](https://velog.io/@miscaminos/Spring-MVC-framework)


