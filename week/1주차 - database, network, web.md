# Database
## ACID
데이터베이스 관리 시스템(DBMS)의 개념으로 지정된 데이터베이스의 안정성을 보장하는 데 사용되는 일련의 표준 속성을 식별 <br/>
<br/>
➿ 데이터베이스 시스템의 4가지 트랜잭션 속성인 원자성, 일관성, 격리 및 내구성을 나타냄

ACID 속성은 모든 데이터베이스 트랜잭션이 정확하고 일관성 있게 유지되도록 하고 처리 작업 중에 발생할 수 있는 오류 복구를 지원 <br/>
<br/>

### 원자성 Atomicity
데이터베이스가 전부 또는 전무 규칙을 따르도록 하는 속성 <br/>
데이터베이스는 모든 트랜잭션 작업을 하나의 전체 단위 또는 원자로 간주, 따라서 데이터베이스가 트랜잭션을 처리할 때 완전히 완료되거나 전혀 실행되지 않음
<br/>

비휘발성 데이터베이스가 트랜잭션 도중에 충돌하면 수행된 모든 변경 사항이 삭제되거나 롤백되어 일부 결과가 프로덕션 데이터베이스로 전송되는 것을 방지 <br/>
<br/>
📌 원자성은 데이터베이스 서버 충돌 시 손상을 완화하는 데 특히 중요
<br/>
<br/>

### 일관성 Consistency
모든 규칙과 제약 조건을 따르는 유효한 데이터만 데이터베이스에 기록되도록 하는 속성 <br/>
트랜잭션이 유효하지 않은 데이터를 생성하면 데이터베이스는 모든 관습적 규칙과 제약 조건을 준수하는 이전 상태로 되돌아감 <br/>

📌 일관성은 데이터 무결성을 유지하는 데 중요
<br/>
<br/>

### 격리 Isolation
각 거래의 개별성을 보장하고 다른 거래의 영향을 받지 않도록 하는 속성 <br/>
거래가 간섭 없이 동시에 안전하고 독립적으로 처리되도록 보장하지만 거래 순서를 보장하지는 않음 <br/>

다른 트랜잭션이 완료될 때까지 기다려야 하며 일관성 없는 데이터를 방지 <br/>
<br/>

### 내구성 Durability
완료된 트랜잭션을 적용하는 속성 <br/>
트랜잭션 각각이 커밋되면 후속 오류가 발생하더라도 시스템에 그대로 유지됨 <br/>
<br/>
트랜잭션이 성공하면 트랜잭션에 의해 생성된 모든 변경 사항이 영구적으로 저장됨 <br/>
<br/>

출처 : https://www.techopedia.com/definition/23949/atomicity-consistency-isolation-durability-acid-database-management-system

---

## Isolation Level 이란?
Transaction에서 일관성 없는 데이터를 허용하도록 하는 수준을 뜻합니다.
<br>
## Isolation Level의 필요성
데이터베이스는 ACID 특징과 같이 트랜잭션이 독립적인 수행을 하도록 합니다.따라서 **Locking을 통해 트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하도록 막는 것이 필요**합니다.
<br/> 하지만 무조건 Locking으로 동시에 수행되는 수많은 트랜잭션들을 순서대로 처리하는 방식으로 구현하게 되면 데이터베이스의 성능은 떨어지게 될 것입니다.
<br/> 그렇다고 해서 성능을 높이기 위해 Locking의 범위를 줄인다면, 잘못된 값이 처리될 문제가 발생하게 됩니다. 따.라.서 최대한 효율적인 Locking 방법이 필요합니다.
<br>
### Isolation Level 종류
1. **Read Uncommitted (Level 0)**
   **SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는 계층**
   트랜잭션에 처리중이거나, 아직 Commit 되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용합니다. 데이터베이스의 일관성을 유지하는 것이 불가능합니다.
> 사용자1이 A라는 데이터를 B라는 데이터로 변경하는 동안 사용자2는 아직 완료되지 않은(Uncommitted) 트랜잭션이지만 데이터B를 읽을 수 있다.

<br>

2. **Read Committed (Level 1)** <br/>
   **SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리는 계층**
   트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하게 됩니다. 그리고 Commit이 이루어진 트랜잭션만 조회가 가능합니다. 대부분 SQL 서버가 Default로 사용하는 Isolation Level 입니다.
> 사용자 1이 A라는 데이터를 B라는 데이터로 변경하는 동안 사용자2는 해당 데이터에 접근이 불가능합니다.

<br>

3. **Repeatable Read (Level 2)**
   **트랜잭션이 완료될 때 까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 계층입니다.**
   트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장합니다. 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정은 불가능합니다! MySQL에서 Default로 사용하는 레벨입니다.

<br>

4. **Serializable (Level 3)**
   **트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 계층**
   완벽한 읽기 일관성 모드를 제공합니다. 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 및 입력이 불가능합니다.

<br>
<br>

### Level 선택할 때 고려해야할 부분은?
- **Isolation 원칙을 덜 지키는 Level을 사용할수록 문제가 발생할 가능성은 커지지만 동시에 더 높은 동시성을 얻을 수 있습니다.**<br/>
- **동시성을 증가시키면 데이터 무결성에 문제가 발생합니다. 동시에 데이터 무결성을 유지하면 동시성이 떨어집니다**<br/>
- **또한, 레벨을 높게 조정할수록 발생하는 비용이 증가합니다**

<br>

### 낮은 단계 Isolation Level을 활용할 때 발생하는 현상
- Dirty Read
  커밋되지 않은 수정중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생하는 현상입니다.
  어떤 트랜잭션에서 아직 실행이 끝나지 않은 다른 트랜잭션에 의한 변경사항을 보게되는 경우를 뜻합니다.
> 발생 Level: Read Uncommitted
<br>
- Non-Repeatable Read
  한 트랜잭션에서 같은 쿼리를 두 번 수행할 때 그 사이에 다른 트랜잭션 값을 수정 또는 삭제하면서 두 쿼리의 결과가 상이하게 나타나는 일관성이 깨진 현상을 말합니다.
>발생 Level: Read Committed, Read Uncommitted
<br>
- Phantom Read
  한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽었을 때, 첫번째 쿼리에서 없던 레코드가 두번째 쿼리에서 나타나는 현상을 말합니다.
  트랜잭션 도중 새로운 레코드 삽입을 허용하기 때문에 나타나는 현상입니다.
>발생 Level: Repeatable Read, Read Committed, Read Uncommitted

---

## Database, DBMS, SQL
_**Databse**_
 - 일반적으로 컴퓨터 시스템에 전자 방식으로 저장된 구조화된 정보 또는 데이터의 체계적인 집합을 의미

 

_**DBMS(DataBase Management System)**_ 
- 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해 주고 데이터베이스를 관리해 주는 소프트웨어

 

_**SQL(Strucured Query Language)**_ 
- 관계형 데이터베이스 관리 시스템의 데이터를 관리하기 위해 설계된 특수 목적의 프로그래밍 언어 
- 관계형 데이터베이스 관리 시스템에서 자료의 검색과 관리, 데이터베이스 스키마 생성과 수정, 데이터베이스 객체 접근 조정 관리를 위해 고안

</br>

### RDBMS
_**RDBMS(Relational Database Management System) **_
- 관계형 데이터베이스(RDB) 관리 시스템을 의미, RDB는 관계형 데이터 모델을 기초로 두고 모든 데이터를 2차원 테이블 형태로 표현하는 데이터베이스
- 기존의 RDBMS에서의 저장 방식은 SQL에 의해 저장되고 있으며 정해진 스키마에 따라 데이터를 저장해야 함
- 구성된 테이블이 다른 테이블들과 관계를 맺고 모여있는 집합체로 이해 가능
- 관계를 나타내기 위해 외래 키(foreign key) 사용
- 외래 키를 이용한 테이블 간 Join이 가능

</br>

### NoSQL
**_NoSQL(Not Only SQL)_**
- RDB 형태의 관계형 데이터베이스가 아닌 다른 형태의 데이터 저장 기술을 의미
- RDBMS와는 달리 테이블 간 관계를 정의x. 
데이터 테이블은 그냥 하나의 테이블이며 테이블 간의 관계를 정의하지 않아 일반적으로 테이블 간 Join도 불가능
 

- 점점 빅데이터의 등장으로 인해 데이터와 트래픽이 기하급수적으로 증가함에 따라 데이터 일관성은 포기하되 비용을 고려하여 여러 대의 데이터에 분산하여 저장하는 Scale-Out을 목표로 등장(RDBMS는 Scale-up을 위해 많은 비용이 듬)

- RDBMS 스키마에 맞추어 데이터를 관리해야 된다는 한계를 극복하고 수평적 확장성(Scale-out)을 쉽게 할 수 있다는 장점을 가지고 있음


- SQL은 정해진 스키마를 따르지 않으면 데이터 추가가 불가능하지만 NoSQL에서는 다른 구조의 데이터를 같은 컬렉션에 추가가 가능

- 문서(documents)는 Json과 비슷한 형태로 가지고 있음. 관계형 데이터베이스처럼 여러 테이블에 나누어담지 않고, 관련 데이터를 동일한 '컬렉션'에 넣음(레코드를 문서(documents)라고 함)

- 예) SQL에서 진행한 Orders, Users, Products 테이블로 나눈 것을 NoSQL에서는 Orders에 한꺼번에 포함해서 저장
따라서 여러 테이블에 조인할 필요없이 이미 필요한 모든 것을 갖춘 문서를 작성하는 것이 NoSQL이다. (NoSQL에는 조인이라는 개념이 존재하지 않음)


`조인하고 싶을 때 NoSQL은 어떻게 할까?`

- 컬렉션을 통해 데이터를 복제하여 각 컬렉션 일부분에 속하는 데이터를 정확하게 산출
- 하지만 이러면 데이터가 중복되어 서로 영향을 줄 위험이 있다. 따라서 조인을 잘 사용하지 않고 자주 변경되지 않는 데이터일 때 NoSQL을 쓰면 상당히 효율적이다.






</br>
</br>



> <용어정리>
>
>`스키마`
- 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 메타데이터의 집합
-  데이터베이스를 구성하는 데이터 개체(Entity), 속성(Attribute), 관계(Relationship) 및 데이터 조작 시 데이터 값들이 갖는 제약 조건 등에 관해 전반적으로 정의


</br>
</br>

>[스키마](https://coding-factory.tistory.com/216)

---

## SQL (관계형 데이터베이스)
SQL은 Structured Query Language, 즉 '구조화 된 쿼리 언어'의 약자입니다.
<br/>
이말은 즉 _데이터베이스 자체를 나타내는 것이 아니라_ **특정 유형의 데이터베이스와 상호 작용하는 데에 사용하는 쿼리 언어**를 뜻합니다.
<br/>
하지만 보통 SQL을 쿼리 언어라기 보다는 '관계형 데이터베이스' 라는 의미로 사용합니다.
<br/>
SQL을 사용하면 관계형 데이터베이스 관리 시스템(RDBMS)에서 데이터를 저장, 수정, 삭제, 검색이 가능합니다.
<br/>
<br>
> **관계형 데이터베이스의 주요 특징 두가지**
> 1. 데이터는 **정해진, 엄격한 데이터 스키마(=structure)를 따라** 데이터베이스 테이블에 저장됩니다.
> 2. 데이터는 **관계**를 통해서 연결된 **여러개의 테이블에 분산**됩니다.
     <br/>
## 정해진, 엄격한 스키마란?
데이터는 테이블(table)에 레코드(record)로 저장됩니다. 각 테이블에는 명확하게 정의된 구조(structure)가 있습니다.
<br/> 여기서 '구조'란 어떤 데이터가 테이블에 들어가고 어떤 데이터가 그렇지 않을지를 정의하는 필드(field) 집합을 가르킵니다.
<br/>
관계형 데이터베이스에서 **스키마를 준수하지 않는 레코드는 추가할 수 없습니다.**
<br>
<br>
## NoSQL (비관계형 데이터베이스)
**스키마 없고! 관계도 없고!**

NoSQL은 기본적으로 SQL과 반대되는 접근방식을 따르기 때문에 지어진 이름입니다. 그래서 No가 붙었다니 조금 신기합니다.

> **비관계형 데이터베이스의 주요 특징 두가지**
<br/>

> 1. 스키마가 없습니다.
> 2. 관계가 없습니다.


<br/>

NoSQL 세계관에서 레코드를 문서(documents)라고 부릅니다. 단순히 이름만 다른 것이 아니라, 핵심적인 차이점이 있습니다. <br/>
바로 **SQL 세상에서는 정해진 스키마를 따르지 않는다면 데이터를 추가할 수 없지만, NoSQL에서는 다른 구조의 데이터를 같은 컬렉션(=SQL에서의 테이블)에 추가할 수 있다는 점입니다!**
<br/>
## SQL vs NoSQL

### SQL의 장점
- 명확하게 정의 된 스키마 = **데이터 무결성 보장**
- 관계는 각 데이터를 중복없이 한번만 저장됨

### NoSQL의 장점
- 스키마가 없기 때문에, 훨씬 더 **유연**함.
  즉, 언제든지 저장된 데이터를 조정하고 새로운 '필드'를 추가 할 수 있음
- 데이터는 애플리케이션이 필요로 하는 형식으로 저장됨.
  = 데이터를 읽어오는 **속도가 빨라짐**
- 수직 및 **수평 확장이 가능**하므로 데이터베이스가 애플리케이션에서 발생시키는 모든 읽기 / 쓰기 요청을 처리 할 수 있음

### SQL의 단점
- **데이터 스키마는 사전에 계획되어야 함** = 상대적으로 덜 유연함.
  (나중에 수정하기가 번거롭고 불가능 할 수도 있음)
- 관계를 맺고 있기 때문에, Join문이 많고 매우 복잡한 쿼리가 만들어 질 수 있음
- **수평적 확장이 어렵고**, 대체로 수직적 확장만 가능함
  즉 어떤 시점에서 처리 할 수 있는 처리량과 관련하여 성장 한계에 직면함

### NoSQL의 단점
- 유연성 때문에 데이터 구조 결정을 하지 못하고 미루게 될 수 있음
- 데이터 중복은 여러 컬렉션과 문서가 여러 레코드가 변경된 경우 업데이트 해야 함

- 데이터가 여러 컬렉션에 중복되어 있어서 **수정을 해야하는 경우 모든 컬렉션에서 수행**해야 함
  (SQL은 중복된 데이터가 없기 때문에 한번만 수행하면 됨)

그렇다면 각각 어떨 때 써줘야 맞는 걸까?
<br>
### SQL은 언제 사용할까?
- 관계를 맺고 있는 데이터가 자주 변경(수정)되는 애플리케이션일 경우
  (NoSQL에서라면 여러 컬렉션을 모두 수정해줘야만 합니다.)
- 변경될 여지가 없고, 명확한 스키마가 사용자와 데이터에게 중요한 경우

### NoSQL은 언제 사용할까?
- 정확한 데이터 구조를 알 수 없거나 변경 / 확장 될 수 있는 경우
- 읽기(read)처리를 자주하지만, 데이터를 자주 변경(update)하지 않는 경우
  (즉, 한번의 변경으로 수십 개의 문서를 업데이트 할 필요가 없는 경우)
- 데이터베이스를 수평으로 확장해야 하는 경우 ( 즉, 막대한 양의 데이터를 다뤄야 하는 경우)

---

# Transaction 이란 무엇일까?
## Transaction
Transaction 이란, **데이터베이스의 데이터를 조작하는 작업의 단위(unit of work)** 입니다.<br/>
은행에서 쓰는 송금으로 예를들면, 송금은 _1. 보내는 사람의 계좌에서 돈을 빼고_, _2. 받는 사람의 계좌에 돈을 추가_ 하는 두가지 행위가 묶인 하나의 작업입니다.

Transaction은 흔히 이론적으로 `ACID` 원칙을 만족/보장 해야 한다고 말합니다.<br/>
여기서 `ACID` 란, `Atomicity(원자성)`, `Consistency(일관성)`, `Isolation(독립성)`, `Durability(영구성)` 를 뜻합니다.
<br/>각 원칙은 아래와 같은 성질을 의미합니다.
<br>

- **Atomicity(원자성)**
  만약 Transaction 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.
  <br>즉, Transaction 작업이 부분적으로 성공하는 일이 없도록 보장하는 성질입니다. 송금하는 사람의 계좌에서 돈은 빠져나갔는데 받는 사람의 계좌에 돈이 들어오지 않는 일이 없도록!

<br>

- **Consistency(일관성)**
  Transaction이 완료된 다음의 상태에서도 Transaction이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.
  <br>즉 Transaction이 끝날 때 DB의 여러 제약 조건에 맞는 상태를 보장하는 성질입니다. 송금하는 사람의 계좌 잔고가 0보다 작아지면 안 됩니다!

<br>

- **Isolation(독립성)**
  각각의 Transaction은 서로 간섭없이 독립적으로 수행되어야 한다.
  <br>즉 Transaction이 진행되는 중간상태의 데이터를 다른 Transaction이 볼 수 없도록 보장하는 성질입니다. 송금하는 사람의 계좌에서 돈은 빠져나갔는데 받는 사람의 계좌에 돈이 아직 들어가지 않은 DB의 상황을 다른 Transaction이 읽으면 안 됩니다.

<br>

- **Durability(영구성)**
  Transaction이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.
  <br>Transaction이 성공했을 경우 해당 결과가 영구적으로 적용됨을 보장하는 성질입니다. 한번 송금이 성공하면 은행 시스템에 장애가 발생하더라도 송금이 성공한 상태로 복구할 수 있어야 합니다.

---
## 데이터베이스의 유형과 특징
1. 관계형 데이터베이스
2. NoSQL 


## 관계형 데이터베이스(RDB)
### 관계형 데이터베이스의 특징
- 데이터가 명확하게 정의된 데이터 스키마에 따라 테이블에 저장된다. 정해진 스키마를 따르지 않으면 데이터가 저장되지 않는다. (데이터의 무결성을 보장한다.)
- 데이터가 관계를 통해 여러 테이블에 분산된다. (데이터의 중복을 방지할 수 있다.)

### 관계형 데이터베이스의 구조
- 스키마는 데이터베이스에 저장되는 데이터 구조와 제약조건을 정의한 것이다. (스키마 : 데이터베이스 : 테이블 = 평면도 : 집 : 방)
- 테이블은 행(row)과 열(column)로 이루어져있다. 테이블의 행은 record 라고도 부르며, 데이터 한 건에 해당한다.
- RDBMS(데이터베이스 관리 시스템)는 SQL을 사용해 데이터 검색과 관리, 데이터베이스 스키마를 생성, 수정, 데이터베이스 객체 접근 조정을 관리한다.
- RDBMS는 일반적으로 클라이언트가 요청을 보내면 서버가 처리하는 구조이다. 클라이언트가 요청을 보낼 때 사용하는 특수 목적의 프로그래밍 언어가 SQL 이다.

### RDBMS의 종류
- Oracle DB - 가장 오래되었고 신뢰도도 높다. 뛰어난 기술력과 안정성을 가지고 있다. 대규모의 애플리케이션, 특히 은행 업계에서 쓰이며, 유료로 사용해야 한다.
- MySQL - 오픈 소스이기 때문에 널리 쓰인다. 웹 개발, 특히 PHP를 이용한 개발에 흔히 쓰인다. 오라클이 인수한 후 불안감 때문에 다른 곳으로 넘어가는 경우가 종종 보인다.
- Maria DB - 오라클이 MySQL을 인수하면서 라이선스 문제가 불확실해지자, 이에 반발하여 만들어졌다. MySQL 5.5를 기반으로 만들어져 사용법이 거의 유사하고 호환성도 뛰어나다.
- RDBMS는 스키마가 변경 될 여지가 없는 경우, 데이터의 변경이 자주 일어나는 경우, 트랜잭션 처리가 중요한 경우, 데이터의 정확한 처리가 필수적인 시스템에 사용한다.

 

## NoSQL
### NoSQL의 특징 
- 정해진 스키마가 없고, 스키마를 사용하지 않거나 느슨한 스키마를 사용할 수 있다.(스키마에 맞지 않는 데이터를 추가할 수 있고, 새로운 필드 추가 등 유연한 관리가 가능하다.)
- 관계가 없다.(데이터가 여러 컬렉션에 중복될 수 있고 모든 컬렉션을 수정해야한다. 따라서 비관계적, 비구조적, 대용량인 데이터 조회, 저장 등에 사용.)
- NoSQL은 정확한 데이터 구조를 알 수 없고 데이터가 변경/확장이 될 수 있는 경우에 사용하는 것이 좋습니다. 또한 단점에서도 명확하듯이 데이터 중복이 발생할 수 있으며 중복된 데이터가 변경될 시에는 모든 컬렉션에서 수정을 해야 합니다. 이러한 특징들을 기반으로 Update가 많이 이루어지지 않는 시스템이 좋으며 또한 Scale-out이 가능하다는 장점을 활용해 막대한 데이터를 저장해야 해서 Database를 Scale-Out를 해야 되는 시스템에 적합합니다.

### NoSQL의 종류
- Key-Value Model : Key-Value Database는 데이터가 Key와 Value의 쌍으로 저장된다. Key는 Value에 접근하기 위한 용도로 사용되며, 값은 어떠한 형태의 데이터라도 담을 수 있다. 심지어는 이미지나 비디오도 가능하다. 또한 간단한 API를 제공하는 만큼 검색 속도가 굉장히 빠른 편이다. 주로 SERVER CONFIG, SESSION CLUSTERING등에 사용된다. ex) Redis
- Document Model : Documnet Database 데이터는 Key와Document의 형태로 저장된다. Key-Value 모델과 다른 점이라면 Value가 계층적인 형태인 도큐먼트로 저장된다는 것이다. 객체지향에서의 객체와 유사하며, 이들은 하나의 단위로 취급되어 저장된다. 다시 말해 하나의 객체를 여러 개의 테이블에 나눠 저장할 필요가 없어진다는 뜻이다. 주요한 특징으로는 객체-관계 매핑이 필요하지 않다. 객체를 Document의 형태로 바로 저장 가능하기 때문이다. 또한 검색에 최적화되어 있는데, 이는 Ket-Value 모델의 특징과 동일하다. 단점이라면 사용이 번거롭고 쿼리가 SQL과는 다르다는 점이다. 도큐먼트 모델에서는 검색의 결과가 JSON이나 xml 형태로 출력되기 때문에 그 사용 방법이 RDBMS에서의 검색 결과를 사용하는 방법과 다르다. ex) MongoDB
- Column Model : 행Column-family Model 기반의 Database이며 이전의 모델들이 Key-Value 값을 이용해 필드를 결정했다면, 특이하게도 이 모델은 키에서 필드를 결정한다. 키는 Row(키 값)와 Column-family, Column-name을 가진다. 연관된 데이터들은 같은 Column-family 안에 속해 있으며, 각자의 Column-name을 가진다. 관계형 모델로 설명하자면 어트리뷰트가 계층적인 구조를 가지고 있는 셈이다. 이렇게 저장된 데이터는 하나의 커다란 테이블로 표현이 가능하며, 검색은 Row, Column-family, Column-name을 통해 수행된다. ex) HBase, Cassandra, ScyllaDB
- Graph Model : 데이터를 노드로 표현하며 노드 사이의 관계를 엣지로 표현한다. 데이터간의 관계를 저장한다. 데이터 간의 관계가 탐색의 키일 경우에 적합하다. 페이스북이나 트위터 같은 소셜 네트워크에서(내 친구의 친구를 찾는 검색 등) 적합하고, 연관된 데이터를 추천해주는 추천 엔진이나 패턴 인식 등의 데이터베이스로도 적합하다.
---
### reference
- https://blog.yena.io/studynote/2018/10/02/DBMS-SQL.html
- https://im-designloper.tistory.com/67
- https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database#nosql
- https://www.samsungsds.com/kr/insights/1232564_4627.html
- https://code-lab1.tistory.com/53
- https://khj93.tistory.com/entry/Database-RDBMS%EC%99%80-NOSQL-%EC%B0%A8%EC%9D%B4%EC%A0%90

---
# 데이터베이스 유형 

### 관계형 데이터베이스 RDB
열과 행이 있는 테이블 집합으로 구성
* 열 : 특정 종류의 데이터를 수록
* 필드 : 속성의 실제 값을 저장
* 행 : 한 객체 또는 엔터티와 관련된 값들의 모음을 나타냄 

데이터 항목 간에 사전 정의된 관계가 있을 때 그러한 데이터 항목들의 모음 <br/>
테이블은 데이터베이스에 표시할 해당 객체들에 관한 정보를 수록하는 데 사용 <br/>

<br/>
테이블의 각 행은 기본 키라고 부르는 고유 식별자로 표시 가능 & 여러 테이블에 있는 행들은 외래 키를 사용하여 상호 연결 <br/>
<br/>


### 객체 지향 데이터베이스 OODB
같은 영역의 각 객체(정보)를 한데 묶어 하나의 객체 집합의 성격을 정의하고 
다시 각 객체 집합의 내부 계층 구도 및 객체 집합 간의 연결 구조를 확립시켜 어떠한 복잡한 사건(event)을 즉각적으로 표현할 수 있도록 하는 시스템 <br/>
데이터를 완전한 객체로 직접 처리 ➿ 모든 정보는 여러 테이블 대신 즉시 사용 가능한 하나의 개체 패키지로 제공

> 관계형 데이터베이스와 객체 지향 데이터베이스의 차이 <br/>
> RDB : 모든 정보를 2차원 형태의 도표에 의해 서로 관련 지어 표현 <br/>
> OODB : 모든 정보를 객체라는 형태로 표현
 
<br/>

### 분산 데이터베이스
* 여러 곳으로 분산되어있는 데이터베이스를 하나의 가상 시스템으로 사용할 수 있도록 한 데이터베이스
* 논리적으로 동일한 시스템에 속하지만, 컴퓨터 네트워크를 통해 물리적으로 분산되어 있는 데이터들의 모임. 물리적 Site 분산, 논리적으로 사용자 통합·공유

즉, 분산 데이터베이스는 데이터베이스를 연결하는 빠른 네트워크 환경을 이용하여 데이터베이스를 여러 지역 여러 노드로 위치시켜 사용성/성능 등을 극대화 시킨 데이터베이스

<br/>

### 데이터 웨어하우스
* 빠른 쿼리 및 분석을 위해 특별히 설계된 데이터베이스 유형
* 다양한 소스에서 얻은 대량의 데이터를 연결, 통합하는 디지털 스토리지 시스템
* 목적 : 목적은 비즈니스 인텔리전스(BI), 리포팅, 분석을 제공하고 규제 요구사항을 지원해 기업이 데이터를 인사이트로 전환하고 데이터 기반의 스마트한 의사결정을 지원
<br/>

### NoSQL 데이터베이스
기존의 관계형 데이터베이스 보다 더 융통성 있는 데이터 모델을 사용하고, 데이터의 저장 및 검색을 위한 특화된 매커니즘을 제공
<br/>
<br/>
가장 널리 사용되는 네 가지 NoSQL 데이터베이스 유형 <br/>
<img width="1085" alt="스크린샷 2022-09-15 오후 2 49 18" src="https://user-images.githubusercontent.com/84092014/190324489-7ab0df8a-0d9f-4c53-9518-b6bf1467d508.png">
- 키-값 : 해시 테이블을 사용하여 키와 값의 쌍을 저장
- 문서 : 문서 전체를 컬렉션이라 불리는 그룹으로 구성하여 키-값 데이터베이스의 개념을 확장, 중첩된 키-값 쌍을 지원
- 열 형식 = 와이드 열, 열 패밀리 데이터베이스 : 희소 데이터 행에 걸쳐 데이터와 쿼리를 효율적으로 저장
- 그래프 : 상호 연결된 데이터를 표현하고 복잡한 관계를 간단하게 스토리지하고 살펴볼 수 있도록 지원

<br/>

### 그래프 데이터베이스
엔티티 및 엔티티 간의 관계 측면에서 데이터를 저장 <br/>
그래프 생성 및 조작이라는 단일 용도로 특별히 설계된 플랫폼 <br/>
그래프는 노드, 간선, 속성으로 구성되어 있으며, 이 모든 요소를 활용하여 관계형 데이터베이스에서는 불가능한 방식으로 데이터를 표현하고 저장 <br/>

<br/>

### 오픈 소스 데이터베이스
소스 코드가 오픈 소스인 시스템 <br/>
<br/>
보편적으로 사용되는 오픈소스 관계형 DB
* MySQL
* PostgreSQL
* MariaDB

보편적으로 사용되는 오픈소스 NoSQL DB
* MongoDB
* CouchDB
* Cassandra

<br/>

### 클라우드 데이터베이스
클라우드 플랫폼을 통해 구축하고 액세스할 수 있는 데이터베이스 서비스 <br/>
사용자가 클라우드 인프라에 소프트웨어를 설치하여 데이터베이스를 구현 <br/>
<br/>

### 다중 모델 데이터베이스
서로 다른 유형의 데이터베이스 모델을 단일 통합 백엔드로 결합 <br/>

<br/>

### 문서/JSON 데이터베이스
JSON 유사 형식의 문서로 데이터를 저장 및 쿼리하도록 설계된 비관계형 데이터베이스 유형 <br/>

<br/>

### 자율 운영 데이터베이스
머신 러닝을 활용해 기존의 경우 DBA가 수행하던 데이터베이스 튜닝, 보안, 백업, 업데이트 및 기타 일상적인 관리 업무를 자동화하는 클라우드 데이터베이스 <br/>
기존 데이터베이스와 달리 자율 운영 데이터베이스는 이러한 모든 작업을 사람의 개입없이 수행 <br/>

<br/>

참고 자료 <br/>
[데이터베이스 유형_Oracle](https://www.oracle.com/kr/database/what-is-database/) <br/>
[관계형 데이터베이스_AWS](https://aws.amazon.com/ko/relational-database/)  <br/>
[객체 지향 데이터베이스_MongoDB](https://www.mongodb.com/databases/what-is-an-object-oriented-database)  <br/>
[분산 데이터베이스_DATA ON-AIR](https://dataonair.or.kr/db-tech-reference/d-guide/sql/?mod=document&uid=336) <br/>
[데이터웨어하우스_SAP](https://www.sap.com/korea/insights/what-is-a-data-warehouse.html) <br/>
[NoSQL_Azure](https://azure.microsoft.com/ko-kr/resources/cloud-computing-dictionary/what-is-nosql-database/) <br/>
[그래프 데이터베이스_Oracle](https://www.oracle.com/kr/autonomous-database/what-is-graph-database/) <br/>
[오픈 소스 데이터베이스_PURESTORAGE](https://www.purestorage.com/kr/knowledge/what-is-an-open-source-database.html) <br/>
[클라우드 데이터베이스_IBM](https://www.ibm.com/kr-ko/cloud/learn/what-is-cloud-database) <br/>

---

# 인덱스
인덱싱은 쿼리를 처리할 때 필요한 디스크 액세스 수를 최소화하여 데이터베이스 성능을 최적화하는 방법 <br/> <br/>

인덱스는 쿼리 속도를 높이기 위해 데이터베이스 백그라운드에서 사용되는 강력한 도구 <br/>
인덱스에는 항목에 빠르고 효율적으로 액세스하는 데 필요한 모든 정보가 포함됨 <br/>
인덱스는 보다 빠른 검색을 위해 데이터를 효율적으로 저장하는 조회 테이블 역할을 수행 <br/>
고속의 검색 동작뿐만 아니라 레코드 접근과 관련 효율적인 순서 매김 동작에 대한 기초를 제공 <br/>
<br/>

인덱스는 두 열의 조합으로 생성됨 <br/>
- 첫 번째 열 : 검색 키 → 정렬된 순서로 저장
- 두 번째 열 : 데이터 참조 또는 포인터 ➿ 해당 키 값을 찾을 수 있는 디스크 블록의 주소가 포함됨 

<br/>

## Index 자료구조
### 해시 테이블(Hash Table)Permalink
Key-Value 형태로 데이터를 저장하는 자료구조 <br/>
<b>내부적으로 배열(버킷)을 사용</b>하여 데이터를 저장하기 때문에 빠른 검색 속도를 제공 <br/>
데이터 탐색 시 해시 함수(Hash Function)를 이용해 Key에 해당하는 index 값을 구함 <br/>
index를 이용하여 배열에 저장된 value에 접근하기 때문에 해시 테이블의 평균 시간복잡도는 O(1) <br/>
<img width="850" alt="스크린샷 2022-09-15 오후 4 50 41" src="https://user-images.githubusercontent.com/84092014/190346935-24316e80-1a9b-4647-aba0-453f927409b5.png">


### B-Tree(Balanced Tree)Permalink
B-Tree는 자식 노드의 개수가 2개 이상인 트리 <br/>
Key-Value 값들은 Key를 기준으로 항상 오름차순으로 정렬되어 있음 <br/>
균형 트리(Balanced Tree)로 루트 노드에서 리프 노드까지의 거리가 모두 동일 → 어떤 값에 대해서도 같은 시간에 결과를 얻을 수 있음 <br/>
<br/>
데이터 탐색뿐 아니라, 저장, 수정, 삭제에도 항상 O(logN)의 시간 복잡도를 가짐 <br/>
<br/>
하지만 처음에는 균형 트리 형태이지만 시간이 지나면서 테이블 데이터 갱신(INSERT, UPDATE, DELETE)에 따라 데이터의 균형이 깨지면서 성능이 악화됨 
<img width="768" alt="스크린샷 2022-09-15 오후 4 50 54" src="https://user-images.githubusercontent.com/84092014/190346980-2a731888-d15f-4dcb-91c3-f51979c75989.png">


### B+Tree
B-Tree의 확장된 개념 <br/>
B-Tree와 다르게 브랜치 노드는 Value에 대한 정보가 존재하지 않고 단순히 Key 값만 존재 <br/>
맨 말단 노드인 리프 노드에서만 Value를 관리 <br/>
리프 노드들은 LinkedList 구조로 서로를 참조하고 있기 때문에 B-Tree에 비하여 노드 순회가 쉬움 <br/>

<br/>
B+Tree는 브랜치 노드에 Value가 없기 때문에 B-Tree에 비해 차지하는 메모리가 적지만, Value를 찾기 위해선 리프 노드까지 이동해야 함 <br/>
<img width="869" alt="스크린샷 2022-09-15 오후 4 51 11" src="https://user-images.githubusercontent.com/84092014/190347046-1548b9a2-ce04-4218-80cc-323b944bec6b.png">


### 고려사항
무턱대고 컬럼에 Index를 적용하는 것은 오히려 성능이 저하되는 역효과가 발생할 수 있음 <br/>
→ Index는 항상 최신 상태로 정렬되기 위해, 데이터 갱신(INSERT, UPDATE, DELETE) 작업에 대해 추가적인 연산이 발생
<br/>
<br/>
📌 데이터 갱신보다는 조회에 주로 사용되는 컬럼에 Index를 생성하는 것이 유리 <br/>
<br/>
<br/>
출처  
https://starship-knowledge.com/index-data-structures <br/>
https://junhyunny.github.io/information/data-structure/db-index-data-structure/ <br/>


---

## 트랜잭션이란?
1. 트랜잭션(Transaction)
2. 트랜잭션의 특징(ACID)
3. 트랜잭션의 상태
4. 트랜잭션 격리 수준(Isolation Level)


### 트랜잭션(Transaction)
- 데이터베이스의 상태를 변환시키는 하나의 논리적인 작업 단위를 구성하는 연산들의 집합
- 데이터베이스의 상태를 변환하는 도중 예기치 못한 에러로 잘못된 작업 실행을 방지하기 위하여 사용한다.
- 트랜잭션은 Commit 되거나 Rollback 된다.
- Commit : 한개의 논리적 단위(트랜잭션)에 대한 작업이 성공적으로 끝나 데이터베이스가 다시 일관된 상태에 있을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산이다.
- Rollback : 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 모든 연산을 취소(Undo)하는 연산이다. Rollback 시에는 해당 트랜잭션을 재시작하거나 폐기한다.

### 트랜잭션의 특징(ACID)
- 원자성(Atomicity) : 트랜잭션이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 된다.
- 일관성(Consistency) : 트랜잭션의 작업 처리 결과는 항상 일관성 있어야 한다.
- 독립성(Isolation) : 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다.
- 지속성(Durability) : 트랜잭션이 성공적으로 완료되었으면, 결과는 영구적으로 반영되어야 한다.

### 트랜잭션의 상태
- 활동(Active) : 트랜잭션이 실행 중에 있는 상태, 연산들이 정상적으로 실행 중인 상태
- 장애(Failed) : 트랜잭션이 실행에 오류가 발생하여 중단된 상태
- 철회(Aborted) : 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태
- 부분 완료(Partially Committed) : 트랜잭션이 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태
- 완료(Committed): 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태

### 트랜잭션 격리 수준(Isolation Level)
- 트랜잭션에서 일관성 없는 데이터를 허용하도록 하는 수준
- Locking 이란? : 트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하도록 막는 것
- 격리 수준 조정이 낮으면 동시성이 증가되는데 데이터 무결성에 문제가 발생할 수 있고, 높으면 데이터의 무결성을 유지하는데 동시성이 떨어질 수 있다.

- Read Uncommitted (레벨 0) : SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는 Level
- Read Committed (레벨 1) : SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리는 Level. 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하게 된다. Commit이 이루어진 트랜잭션만 조회할 수 있다. 따라서, 어떤 사용자가 A라는 데이터를 B라는 데이터로 변경하는 동안 다른 사용자는 해당 데이터에 접근할 수 없다. 대부분의 SQL Server가 Default로 사용하는 Isolation Level
- Repeatable Read (레벨 2) : 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 Level. 트랜잭션이 범위 내에서 조회한 데이터의 내용이 항상 동일함을 보장한다. 따라서, 다른 사용자는 그 영역에 해당되는 데이터에 대한 수정이 불가능하다. MySQL에서 Default로 사용하는 Isolation Level
- Serializable (레벨 3) : 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 Level. 완벽한 읽기 일관성 모드를 제공한다. 따라서, 다른 사용자는 그 영역에 해당되는 데이터에 대한 수정 및 입력이 불가능하다.

### reference
- https://github.com/WeareSoft/tech-interview/blob/master/contents/db.md


---

## HTTP 란?
1. HTTP(hyper-text transfer protocol, 하이퍼본문전송규약)
2. HTTP 요청 메세지
3. HTTP 응답 메세지
4. HTTPS(HyperText Transfer Protocol over Secure Socket Layer)
5. 소켓 통신이란
---

### HTTP(hyper-text transfer protocol, 하이퍼본문전송규약)
- 웹 상에서 클라이언트와 서버 간에 요청/응답(request/response) 규칙이다.
- 주로 HTML 문서를 주고받는 데에 쓰인다.
- TCP와 UDP를 사용하며, 80번 포트를 사용한다.
- TCP 위에서 동작하지만 TCP와는 달리 무상태성 혹은 비연결성이다. 때문에 쿠키나 세션을 이용하여 클라이언트의 상태를 관리할 수 있다.
- 비연결(Connectionless) : 클라이언트가 요청을 서버에 보내고 서버가 적절한 응답을 클라이언트에 보내면 바로 연결이 끊긴다.
- 무상태(Stateless) : 연결을 끊는 순간 클라이언트와 서버의 통신은 끝나며 상태 정보를 유지하지 않는다.

### HTTP 요청 메세지
```
GET /restapi/v1.0 HTTP/1.1
Accept: application/json
Authorization: Bearer UExBMDFUMDRQV1MwMnzpdvtYYNWMSJ7CL8h0zM6q6a9ntw
(empty line)
본문
```
- 요청 내용 : GET /images/logo.gif HTTP/1.1
- 헤더 : Accept-Language: en
- 빈 줄 (empty line)
- 본문 : 함께 전송할 데이터가 표시된다.

### HTTP 응답 메세지
```
HTTP/1.1 200 OK
Date: Mon, 23 May 2005 22:38:34 GMT
Content-Type: text/html; charset=UTF-8
Content-Encoding: UTF-8
Content-Length: 138
Last-Modified: Wed, 08 Jan 2003 23:11:55 GMT
Server: Apache/1.3.3.7 (Unix) (Red-Hat/Linux)
ETag: "3f80f-1b6-3e1cb03b"
Accept-Ranges: bytes
Connection: close

<html>
<head>
  <title>An Example Page</title>
</head>
<body>
  Hello World, this is a very simple HTML document.
</body>
</html>
```
- 상태표시 행(status line): 상태코드(status code)와 reason message를 포함한다. (예. HTTP/1.1 200 OK. 클라이언트의 요청이 성공적으로 전달되었음을 표시)
- 응답 헤더필드 (예.Content-Type: text/html)
- 빈 줄 (empty line)
- 본문 : 함께 전송할 데이터

### HTTPS(HyperText Transfer Protocol over Secure Socket Layer)
- HTTPS에서 통신 프로토콜은 TLS(Transport Layer Security) 또는 이전에는 SSL(Secure Sockets Layer)을 사용하여 암호화된다. 따라서 "HTTP over TLS" 또는 "HTTP over SSL" 이라고도 불린다.
- HTTPS의 기본 TCP/IP 포트는 443이다.
- 보호의 수준은 웹 브라우저에서의 구현 정확도와 서버 소프트웨어, 지원하는 암호화 알고리즘에 달려있다.
- HTTPS 웹사이트가 SSL/TLS 인증서로 보호되는 경우 HTTPS가 URL에 표시됩니다. 사용자는 브라우저 표시줄의 자물쇠 기호를 클릭해 발급 기관 및 웹사이트 소유자의 상호를 포함한 인증서의 세부 정보를 볼 수 있습니다.

### TSL(SSL)이란
- SSL: 보안 소켓 계층(Secure Sockets Layer) 인증서는 종종 디지털 인증서로 불리며, 브라우저(사용자의 컴퓨터)와 서버(웹사이트) 사이의 암호화된 연결을 수립하는 데 사용됩니다.
- TLS: 전송 계층 보안(Transport Layer Security) 은 SSL의 향상된, 더욱 안전한 버전입니다. SSL 및 TLS는 본질적으로 같으며 버전이 다른 정도입니다.
- 대칭키 : 암호화에 쓰이는 키와 복호화에 쓰이는 키가 동일한 기법입니다.
- 공개키(비대칭키) : 공개키와 개인키(비밀키)라는 2가지 키를 사용하는 기법입니다.
- 인증서와 CA(Certificate authority) : SSL을 적용하기 위해서는 인증서라는 것이 필요합니다.이 인증서를 발급해주는 기업을 CA라고 합니다. 인증서가 보안에 관련된 것인 만큼 이 CA는 영향력있고 신뢰할수 있는 기업에서만 가능합니다. 그리고 우리의 브라우저는 CA리스트를 미리 가지고 있습니다. CA목록에 있는 기업을 공인된 CA라고 합니다.
- HTTPS 동작방식 : 대칭키와 공개키(비대칭키) 방식을 전부 사용하는 하이브리드 방식입니다. 데이터 전송을 위해 대칭키 방식을 사용하며 대칭키를 안전하게 전달하기 위해 공개키 방식을 사용합니다.

### 소켓 통신이란
- Socket 연결은 TCP/IP 프로토콜을 기반으로 맺어진 네트워크 연결 방식이다.
- HTTP 연결은 TCP/IP 연결을 기반으로 하므로 기본적으로 소켓 연결 위에서 맺어지는 애플리케이션 계층의 연결 방식이다.
- Http 프로그래밍 : Client만 필요한 경우에 요청을 보낼 수 있다.
- Socket 프로그래밍 : Server 역시 Client로 요청을 보낼 수 있으며, Server와 Client가 특정 Port를 통해 연결을 유지하고 있어 실시간으로 양방향 통신을 할 수 있다.

---
reference
- https://ko.wikipedia.org/wiki/HTTP
- https://www.zerocho.com/category/HTTP
- https://bitcodic.tistory.com/151
- https://mangkyu.tistory.com/48 
- https://mysterico.tistory.com/29
- https://mysterico.tistory.com/30
- http://www.ktword.co.kr/test/view/view.php?m_temp1=1957
- https://doozi0316.tistory.com/entry/HTTPHTTPS%EB%9E%80-TCP-UDP-HandShake-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC

---

# HTTP vs HTTPS?<br>
###  HTTP (Hyper Text Transfer Protocol)
: **서버/클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜** <br>
→ HTTP는 인터넷에서 하이퍼텍스트를 교환하기 위한 통신 규약, 80번 포트 사용<br> 따라서 HTTP 서버가 80번 포트에서 요청을 기다리고 있으며, 클라이언트는 80번 포트로 요청을 보내게 된다.
###  HTTPS (HyperText Transfer Protocol over 'Secure Socket Layer')
: HTTP에 **데이터 암호화**가 추가된 프로토콜 (443번 포트) <br>
→ 인터넷 상에서 정보를 암호화하기 위해 SSL 프로토콜을 이용해 데이터를 전송하고 있다는 것을 말함. <br>
→ SSL 프로토콜은 정보를 암호화시키고 이때 '공개키'와 '개인키' 두가지를 이용함<br>


<br>

#### ➡︎ HTTP와 HTTPS의 차이
- HTTP는 암호화가 추가되지 않았기 때문에 보안에 취약한 반면, HTTPS는 안전하게 데이터를 주고받을 수 있다. <br> 하지만 HTTPS를 이용하면 암호화/복호화의 과정이 필요하기 때문에 HTTP보다 속도가 느리다. (오늘날에는 거의 차이를 못느낄 정도)<br> 또한 HTTPS는 인증서를 발급하고 유지하기 위한 추가 비용이 발생하다.
#### ➡︎ 그렇다면 언제 HTTP를 쓰고, 언제 HTTPS를 쓰는 것이 좋겠는가?
- 개인 정보와 같은 민감한 데이터를 주고 받아야 한다면 HTTPS를 이용해야 하지만, <br>노출이 되어도 괜찮은 단순한 정보 조회 등 만을 처리하고 있다면 HTTP를 이용하면 된다.
#### ➡︎ 동작순서 차이
- HTTP 동작 순서 : TCP → HTTP
- HTTPS 동작 순서 : TCP → SSL → HTTP
> SSL(Secure Socket Layer)을 쓰냐 안쓰냐의 차이 

즉, **문서 전송시 암호화 처리 유무**에 따라 HTTP와 HTTPS로 나누어지는 것.<br>
모든 사이트가 HTTPS로 하지 않는 이유는, 암호화 과정으로 인한 **속도 저하**가 발생하기 때문이다.

<br><br><br>

#### 출처

[https://mangkyu.tistory.com/98](https://mangkyu.tistory.com/98)<br>
[https://gyoogle.dev/blog/interview/네트워크.html](https://gyoogle.dev/blog/interview/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC.html)


---
# HTTP
**프로토콜(Protocol)** : 컴퓨터들 간의 원활한 통신을 위해 지키기로 약속한 규약

**HTTP(Hypertext Transfer Protocol)**

- 인터넷상에서 데이터를 주고 받기 위해 서버/클라이언트 모델을 따르는 통신규약
- Connectionless 프로토콜 (비연결지향)
  - 클라이언트가 서버에 요청(Request)을 했을 때, 그 요청에 맞는 응답(Response)을 보낸 후 연결을 끊는 처리방식이다.        
   - HTTP 1.1 버전에서 연결을 유지하고, 재활용 하는 기능이 Default 로 추가되었다. (keep-alive 값으로 변경 가능)

- Stateless 프로토콜 (상태정보 유지 안함)
  - 클라이언트의 상태 정보를 가지지 않는 서버 처리 방식이다.    
  - 클라이언트와 첫번째 통신에서 데이터를 주고 받았다 해도, 두번째 통신에서 이전 데이터를 유지하지 않는다.

  
- 클라이언트와 정보를 유지하기 위해 사용하는 것 -> 쿠키와 세션
</br>

# 쿠키(Cookie)
- 웹 사이트에 접속할 때 생성되는 정보를 담은 임시 파일(key,value 구성, String 형태)
- 서버가 사용자의 웹 브라우저에 저장하는 데이터(서버를 이용할 때마다 보여줌)
- 로그아웃, 로그인과 관계없이 삭제하지 않으면 유지됨
- 세션 관리 : 로그인, 사용자 닉네임, 접속  시간, 장바구니 등의 서버가 알아야할 정보들을 저장
- 개인화 : 사용자마다 다르게 그 사람에게 적절한 페이지를 보여줄 수 있음
- 트래킹 : 사용자의 행동과 패턴을 분석하고 기록
- 예시 : 다시 방문하였을 때, 아이디 비번 자동생성, 팝업창 '오늘 다시 보지 않기'


`특징`
1. 이름, 값, 만료일(저장 기간 설정), 경로 정보로 구성되어 있다.
2. 클라이언트에 총 300개의 쿠키를 저장할 수 있다.
3. 하나의 도메인 당 20개의 쿠키를 가질 수 있다.
4. 하나의 쿠키는 4KB(=4096byte)까지 저장 가능하다.


`쿠키 동작 순서`
```
1. 서버에서는 사용자로부터 요청이 있을 때 사용자를 구분하기 위한 임시쿠키 하나를 보내 저장하도록 한다.
2. 저장된 쿠키는 웹 브라우저의 쿠키저장소에 저장된다.
3. 이후 같은 사이트의 서버를 방문할 때마다, 저장된 쿠키를 요청할 header에 담아 
   함께 다시 서버로 전송한다.
4. 서버는 전송받은 쿠키와 서버에 저장된 사용자 정보를 비교하여 같은 사용자임을 확인한다.
```
![](https://velog.velcdn.com/images/ilov-/post/384f352c-1eaa-45e2-9a2e-1d25c0b091cc/image.png)

`단점`

- 개인정보가 기록되기 때문에 사생활을 침해할 소지가 있으며, 이를 해소하기 위해 웹 브라우저 자체에 쿠키 거부 기능이 있음(웹 브라우저와의 연결을 지속시키는 기능 수행 x)
- 서버가 아닌 사용자에게 저장되기 때문에 임의로 고치거나 지울 수 있고, 가로채기도 쉬워 보안이 취약(민감한 정보를 담는 것은 위험)

</br>

# 세션(Session)
- 일정 시간동안 같은 사용자(브라우저)로부터 들어오는
일련의 요구를 하나의 상태로 보고, 그 상태를 일정하게 유지시키는 기술

	일정 시간 : 방문자가 웹 브라우저를 통해 웹 서버에 접속한 시점으로부터 웹 브라우저를 종료하여 연결을 끝내는 시점
              즉,방문자가 웹 서버에 접속해 있는 상태를 하나의 단위로 보고 그것을 세션이라고 한다.
- 세션 아이디는 웹 브라우저 당 1개씩 생성되어 웹 컨테이너에 저장되며 브라우저 종료 시 소멸
- 각 클라이언트 고유 Session ID를 부여
(구분하여 각 클라이언트 요구에 맞는 서비스 제공)
- 아이디, 닉넴 등의 정보를 세션에 담아두면 요청이 있을 때마다 DB에 접근할 필요가 없어서 효율적
- 예시 : 화면이 이동해도 로그인이 풀리지않고 유지

`세션 동작 순서`
```
1. 클라이언트가 페이지를 요청한다. (사용자가 웹사이트 접근)
2. 서버는 접근한 클라이언트의 Request-Header 필드인 Cookie를 확인하여,   
   클라이언트가 해당 session-id를 보냈는지 확인한다.
3. session-id가 존재하지 않는다면, 서버는 session-id를 생성해 클라이언트에게 돌려준다.
4. 서버에서 클라이언트로 돌려준 session-id를 쿠키를 사용해 서버에 저장한다.   
   쿠키 이름 : JSESSIONID
5. 클라이언트는 재접속 시, 이 쿠키(JSESSIONID)를 이용하여 session-id 값을 서버에 전달


```

</br>


### Q. 세션을 쓰면되는데 굳이 쿠키를 사용하는 이유?
A. 세션이 쿠키에 비해 보안도 높은 편이나 쿠키를 사용하는 이유는세션은 서버에 저장되고, 서버자원을 사용하기 때문에 사용자가 많을 경우 소모되는 자원이 상당하다.이러한 자원관리 차원에서 쿠키와 세션을 적절한 요소 및 기능에 병행 사용하여,서버 자원의 낭비를 방지하며 웹사이트의 속도를 높일 수 있다.

</br>

# 쿠키와 세션의 차이
||쿠키|세션|
|---|---|---|
|저장 위치| 클라이언트(접속자 PC)|웹 서버|
|저장 형식|text|Object|
|만료 시점|쿠키 저장시 설정 (브라우저가 종료되어도, 만료시점이 지나지 않으면 자동 삭제되지 않음)|브라우저 종료시 삭제 (기간 지정 가능)|
|사용하는 자원(리소스)|클라이언트 리소스|웹 서버 리소스|
|용량 제한|총 300개, 도메인 하나당 200개, 쿠키 하나 당 4KB|용량 제한 x|
|속도|빠름|보다 느림|
|보안|안좋음|좋음|

</br>

>[쿠키와 세션](https://devuna.tistory.com/23)
[보다 자세한](https://hahahoho5915.tistory.com/32)

---

# Cookie와 Session 비교
|      |**Cookie**|**Session**|
|:----:|:---:|:---:|
| 저장위치 |**Client**</br>(클라이언트의 웹 브라우저가 지정하는 메모리 or 하드디스크)|**Server**</br>(서버의 메모리)|
| 저장형식 |**Text**|**Object**|
| 만료시점 |**쿠키 저장시 설정**</br>(설정 없으면 브라우저 종료 시)</br>(expires 속성을 정의해 무효화 시키면 삭제될 날짜 정할 수 있음)|**정확한 시점 모름**</br>(클라이언트가 로그아웃하거나, 설정 시간동안 반응이 없으면 </br>무효화 되기 때문에 정확한 시점 알 수 없음)|
| 리소스  |**클라이언트의 리소스**</br>(클라이언트에 저장되고 클라이언트의 메모리를 사용하기 때문에 서버 자원 사용하지 않음)|**서버의 리소스**</br>(세션은 서버에 저장되고, 서버 메모리로 로딩 되기 때문에 세션이 생길 때마다 리소스를 차지함)|
| 용량제한 |**한 도메인 당 20개, 한 쿠키당 4KB**</br>(클라이언트도 모르게 접속되는 사이트에 의하여 설정될 수 있기 때문에 쿠키로 인해 문제가 발생하는 걸 막고자</br>한 도메인당 20개, 하나의 쿠키 당 4KB로 제한해 둠)|**제한없음**</br>(클라이언트가 접속하면 서버에 의해 생성되므로 개수나 용량 제한 없음)|

---

# 브라우저 기본 구조
![](https://velog.velcdn.com/images/songunnie/post/3f66053a-0fc4-429c-a1ac-34a8d6caf6f7/image.png)

- `사용자 인터페이스`: 사용자가 활용하는 서비스들을 보여준다. (요청한 페이지를 보여주는 창을 제외한 나머지 부분)
>주소 표시줄, 이전/다음 버튼, 북마크 등
- `브라우저 엔진`: 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어한다.
- `렌더링 엔진`: 요청한 콘텐츠를 표시한다
> html 요청이 들어오면 html, css를 파싱해서 화면에 표시
- `통신`: http 요청과 같은 네트워크 호출에 사용한다. (플랫폼의 독립적인 인터페이스로 구현되어있음)
- `UI 백엔드`: 플랫폼에서 명시하지 않은 일반적 인터페이스이다.
- `자바스크립트 해석기`: 자바스크립트 코드를 해석하고 실해한다.
- `자료 저장소`: 쿠키 등 모든 종류의 자원을 하드 디스크에 저장하는 계층이다.

---

# 웹 동작 방식 이해
예를 들어 naver 접속 시 생기는 과정에 대해서 설명해주세요 한다면, <br/>

1. 사용자가 브라우저에 URL(www.naver.com)을 입력
2. DNS 서버에 도메인 네임으로 서버의 진짜 주소를 찾음
3. IP 주소로 웹 서버에 TCP 3 handshake로 연결 수립
4. 클라이언트는 웹 서버로 HTTP 요청 메시지를 보냄
5. 웹 서버는 HTTP 응답 메시지를 보냄
6. 도착한 HTTP 응답 메세지는 웹 페이지 데이터로 변환되고, 웹 브라우저에 의해 출력

출처: https://dev-coco.tistory.com/161 <br/>

---

# 쿠키와 세션

### 쿠키(Cookie)?
HTTP의 일종으로 사용자가 웹 사이트를 방문할 경우,<br>
그 사이트가 **사용하고 있는 서버**에서 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일
### 세션(Session)?
방문자가 웹 서버에 접속해 있는 상태를 하나의 단위로 보고 그것을 세션이라고 함

#### ➡︎ 쿠키와 세션을 사용하는 이유?
- HTTP 프로토콜의 특징이자 약점(비연결성, 비상태성)을 보완하기 위해서 사용<br>
→ 서버와 클라이언트가 통신을 할 때, 통신이 연속적으로 이어지지 않고 한 번 통신이 되면 끊어진다. <br> → 서버는 클라이언트가 누구인지 계속 인증을 해줘야 하는데 그 방법이 쿠키와 세션
#### ➡︎ 쿠키와 세션의 가장 큰 차이점?
- 상태 정보의 저장 위치.
- 쿠키는 클라이언트(웹 브라우저가 지정하는 메모리/ 하드디스크), 세션은 서버의 메모리
#### ➡︎ 세션보다 '쿠키'를 사용하는 이유?
- 세션을 사용하기 위해서는 서버의 자원을 사용해야하는데 자원은 한계가 있고, 속도가 느려질 수 있다는 단점이 있다. <br> 따라서 쿠키와 세션을 적절한 요소 및 기능에 **병행**사용하는 것이 서버 자원의 낭비를 방지하면서 웹사이트의 속도를 높일 수 있다.

<br><br>

>#### 쿠키의 동작 순서
1. 클라이언트가 페이지를 요청(사용자가 웹사이트에 접근)
2. 웹 서버는 쿠키를 생성
3. 생성한 쿠키에 정보를 담아 HTTP 화면을 돌려줄 때, 같이 클라이언트에게 돌려줌
4. 넘겨받은 쿠키는 클라이언트가 가지고 있다가(로컬 PC에 저장) 다시 서버에 요청할 때 요청과 함께 쿠키를 전송
5. 동일 사이트 재방문 시 클라이언트의 PC에 해당 쿠키가 있는 경우, 요청 페이지와 함께 쿠키를 전송

>#### 세션의 동작순서
1. 클라이언트가 페이지를 요청
2. 서버는 접근한 클라이언트의 Request-Header 필드인 **Cookie**를 확인하여, 클라이언트가 해당 `session-id`를 보냈는지 확인
3. `session-id`가 존재하지 않는다면 서버는 `session-id`를 생성해 클라이언트에게 돌려줌
4. 서버에서 클라이언트로 돌려준 `session-id`를 쿠키를 사용해 서버에 저장
5. 클라이언트는 재접속 시, 이 쿠키를 이용해 `session-id` 값을 서버에 전달


<br><br>

| | 쿠키 | 세션 |
| :---: | :---: | :---: |
| 저장위치 | Client | Server |
| 저장형식 | Text | Object |
| **만료시점** | 쿠키 저장시 설정<br>(설정 없으면 브라우저 종료 시) | 정확한 시점 모름 |
| 리소스 | 클라이언트의 리소스 | 서버의 리소스 |
| 용량제한 | 한 도메인 당 20개, <br>한 쿠키당 4KB | 제한없음 |
| 보안 | 취약 | 비교적 좋음 |
| 속도 | 빠름<br>(쿠키에 정보가 존재) | 느림<br>(정보가 서버에 존재) |

<br>

### 캐시(Cache)?
캐시(Cache)는 **웹 페이지 요소를 저장하기 위한 임시 저장소**이고, 쿠키/ 세션은 **정보를 저장**하기 위해 사용된다.<br>캐시는 웹 페이지를 빠르게 렌더링 할 수 있도록 도와주고, 쿠키/ 세션은 사용자의 인증을 도와준다.

<br>

#### 출처
[https://dev-coco.tistory.com](https://dev-coco.tistory.com/61)     
[https://hahahoho5915.tistory.com](https://hahahoho5915.tistory.com/32)<br>
[https://gyoogle.dev](https://gyoogle.dev/blog/web-knowledge/Cookie%20&%20Session.html)
