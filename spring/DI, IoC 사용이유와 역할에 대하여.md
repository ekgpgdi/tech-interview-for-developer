 ## Q1. DI 사용이유
 ### A1. 
- 의존성을 외부에서 주입해 결합도가 낮추기 위해 사용합니다. 그로 인해 코드 수정이 쉬워지며, 테스트 코드 작성도 쉬워집니다.</p>
- IoC를 실현하는데 DI가 필수이며 IoC를 사용하면 귀찮은 객체 생명 주기 같은 프로그램 제어권을 프레임워크가 관리하도록 넘길 수 있습니다.

</br>
</br>

 ## Q2. IoC 컨테이너의 역할
 ### A2.
 **IoC(Inversion of Control)** 
- 메소드나 객체의 호출작업을 개발자가 아닌 Spring Framework에서 결정
- 객체의 생명주기를 관리하고 생성된 인스턴스들에 추가적 기능을 제공하도록 함
- 기존에는 객체를 클래스 내부에서 생성하고 사용했지만 IoC를 적용하면 미리 생성해놓은 객체를 주입받아 사용하기만 하면 됩니다. 
- 객체 간 결합도를 낮춤, 유연한 코드 작성, 가독성 증진, 코드 중복 방지, 유지 보수 용이 등의 장점이 있습니다. 

</br>
</br>

# IoC(Inversion of Control) - 제어의 역전
`IoC`
- 메소드나 객체의 호출작업을 개발자가 아닌 외부에서 결정(외부는 Spring Framework)
- 기존에는 객체를 클래스 내부에서 생성하고 사용했지만 IoC를 적용하면 미리 생성해놓은 **객체를 주입받아** 사용하기만 하면 됨

`장점`

- 객체 간 결합도를 낮춤, 유연한 코드 작성, 가독성 증진, 코드 중복 방지, 유지 보수 용이

`컨테이너`
- 객체의 생명주기를 관리, 생성된 인스턴스들에 추가적 기능을 제공하도록 함


`IoC컨테이너`
- 객체의 생성을 책임지고, 의존성을 관리
- Pojo의 생성,초기화,서비스,소멸에 대한 권한을 가짐, 따라서 개발자는 비지니스 로직에 집중 가능. 


</br>
</br>


# D.I(Dependency Injection) - 의존성 주입
- 객체 사이의 의존 관계를 스프링 설정 파일에 등록된 정보를 바탕으로 컨테이너가 자동으로 처리해주는 것
- 컨테이너가 직접 객체들 사이의 의존관계를 처리하는 것
- 스프링 설정 파일에 등록된 정보를 바탕으로 하기 때문에, 직접 코드를 바꾸지 않고 스프링 설정 파일을 변경하는 것만으로 유지보수가 가능하기 때문에
의존성이 줄어들고, 재사용성과 가독성이 높아지며 보다 객체지향에 부합하는 방식의 코드를 작성가능

### 방법
`1. 생성자 주입` 
```java
@Autowired
public void MemberController(MemberService memberService){
               this. memberService = memberService;
}

@Autowried
필요한 의존객체의 ‘타입’에 해당하는 빈을 찾아서 주입해주는 어노테이션
Ioc컨테이너가 빈으로 등록해주기 때문에, 빈으로 등록 되어 있는 것들은 autowired로 꺼낼 수 있다. 
	→ applicatonContext도 꺼낼 수 있다.
```

- 생성자에 의존성을 주입받고자하는 field를 나열하는 방법.
- 필수적으로 사용해야하는 레퍼런스 없이는 인스턴스를 만들지 못하도록 강제함 - 스프링 컨테이너가 올라오고 어플리케이션이 setting되는 시점에 생성자 주입을 통해 한번만 호출하는 것이 보장되어 `불변, 필수`의존관계에 사용

</br>

`2. Setter 주입`
- set이 public하게 노출될 경우 setter가 실행되어 변경될 수 있는 문제점을 가짐
- 변경가능성이 존재하는 의존관계에서 사용할 필요가 있으나 권장되지 않음 

</br>

`3. 필드 주입`
- 필드에 @Autowired 어노테이션을 붙임. 중간에 외부에서 변경이 불가능하기 때문에 테스트가 힘듦


</br>
</br>

>[DI, IoC ](https://velog.io/@ilov-/Spring-DI-IoC-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%8B%B1%EA%B8%80%ED%86%A4)
