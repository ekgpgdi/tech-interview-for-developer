## Q. 자바 컴파일 과정에 대해 말해주세요.
### A.
1. 텍스트 파일인 자바소스파일을 만들고 컴파일되면 바이트코드파일이 생성됨
2. 바이트 코드파일은 완전한 기계어가 아니므로 구동시키기 위해서 JVM 실행시킴 (명령어 java.exe)
3. 명령어가 실행되면 JVM은 바이트 코드파일을 메모리로 로드
(클래스 로더 -> Runtime Data Area -> Excution Engine)
4. 기계어로 번역
5. main() 메소드 찾아서 실행 
* 실행문 : 변수 선언, 값 저장, 메소드 호출에 해당하는 코드

</br>
</br>

# 자바 컴파일 과정
![](https://velog.velcdn.com/images/ilov-/post/a42c3fd3-d843-4746-800e-90d217bb91aa/image.jpeg)

1. 개발자가 자바 소스코드를 작성
2. 자바 컴파일러가 자바 소스파일을 컴파일  
(이때 나오는 파일은 자바 바이트 코드(.class)파일로 아직 컴퓨터가 읽을 수 없는 자바 가상 머신이 이해할 수 있는 코드)
3. 컴파일된 바이트 코드를 JVM의 클래스로더에게 전달
4. 클래스 로더는 동적로딩(Dynamic Loading)을 통해 필요한 클래스들을 로딩 및 링크하여 JVM의 메모리(Runtime Data area)에 올림
> <details>
><summary>클래스 로더 세부 동작</summary>
>
><!-- summary 아래 한칸 공백 두어야함 -->
>     1. 로드 : 클래스 파일을 가져와서 JVM의 메모리에 로드  
>     2. 검증 : 자바 언어 명세(Java Language Specification) 및 JVM 명세에 명시된 대로 구성되어 있는지 검사  
>     3. 준비 : 클래스가 필요로 하는 메모리를 할당 (필드, 메서드, 인터페이스 등등)  
>     4. 분석 : 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경 -> 추가 공부 필요  
>     5. 초기화 : 클래스 변수들을 적절한 값으로 초기화 (static 필드)  
> </details>
5. Execution Engine은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행 (두가지 방식)

> <details>
><summary>인터프리터, JIT 컴파일러</summary>
>
><!-- summary 아래 한칸 공백 두어야함 -->
>
> 1. 인터프리터 
> - 바이트 코드 명령어를 하나씩 읽어서 해석하고 실행. 하나하나의 실행은 빠르나, 전체적인 실행 속도가 느림. 
>  
> 2. JIT 컴파일러(Just-In-Time Compiler) 
>  - 인터프리터의 단점을 보완하기 위해 도입된 방식으로 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경하고  
>  이후에는 해당 메서드를 더이상 인터프리팅 하지 않고, 바이너리 코드로 직접 실행하는 방식  
>  - 하나씩 인터프리팅하여 실행하는 것이 아니라 바이트 코드 전체가 컴파일된 바이너리 코드를 실행하는 것이기 때문에 전체적인 실행속도는 인터프리팅 방식보다 빠름
></details>



